#!/usr/bin/python
#-*- coding: utf-8 -*-
###########################################################################
# Remote assistance
#
# Copyright (C) 2012 Fotis Tsamis <ftsamis@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FINESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# On Debian GNU/Linux systems, the complete text of the GNU General
# Public License can be found in `/usr/share/common-licenses/GPL".
###########################################################################

import sys
import subprocess
if __name__ == '__main__' and len(sys.argv) > 1:
    cmd = "socat" # FIXME: Set the correct socat command
    subprocess.Popen(cmd, shell=True)
    exit()
import signal
import os
import gtk
import gobject

from epoptes.common import config

pid = os.getpid()


class Support:
    def __init__(self):
        self.wTree = gtk.Builder()
        self.wTree.add_from_file('/usr/share/epoptes/remote_assistance.ui')
        signal.signal(signal.SIGUSR1, self.connected)
        signal.signal(signal.SIGUSR2, self.disconnected)
        self.wTree.connect_signals(self)
        self.get = self.wTree.get_object
        
        self.status_icon = self.get('status_icon')
        self.status_label = self.get('status_label')
        self.method_combo = self.get('method_combobox')
        self.action_button = self.get('connect_button')
        self.status_box = self.get('status_hbox')
        self.action_signal_handler = self.action_button.connect('clicked', self.connect)
        self.spinner = gtk.Spinner()
        self.spinner.set_size_request(16, 16)
        self.status_box.pack_start(self.spinner, False)
        self.status_box.reorder_child(self.spinner, 0)
        
        self.timeout_id = None
        
        self.retry = False
        self.retry_interval = 10
        self.manually_stoped = False
        
        self.proc = None
        self.host = ''
        self.has_connected = False
        
        self.get('support_dialog').show()
        
        
    def connect(self, widget=None):
        '''Gets called when the user presses Connect button'''
        
        self.host = self.get('host_entry').get_text().strip()
        cmd = "x11vnc -q -nopw -connect_or_exit '%s' -afteraccept 'kill -USR1 %d'; kill -USR2 %d" %(self.host, pid, pid)
        if self.method_combo.get_active() == 1:
            cmd = 'socat tcp:server:5500 SYSTEM:"{ kill -USR1 %d; sleep 1; xterm -e screen -xRR ra$$; } & exec screen -S ra$$",pty,stderr; kill -USR2 %d' %(pid, pid)
        self.proc = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        
        # Set the status as "Connecting"
        if self.timeout_id:
            gobject.source_remove(self.timeout_id)
            self.timeout_id = None
        self.set_state('connecting')
        
    
    def connected(self, signum, frame):
        '''Gets called when the program receives SIGUSR1 (succesful connection)'''
        self.set_state('connected')
    
    def disconnect(self, widget):
        if self.timeout_id:
            self.set_state('disconnected')
            gobject.source_remove(self.timeout_id)
            self.timeout_id = None
            self.manually_stopped = True
        
        #FIXME: Kill the process.
        self.proc.kill()
        self.set_action_button('connect')
    
    def disconnected(self, signum=None, frame=None):
        '''Gets called when the program receives SIGUSR2
        (failed connection or disconnect)'''
        
        # If there was no connection before, this is not a disconnect
        # but a failed attempt to connect. So display an appropriate message.
        if self.has_connected:
            self.set_state('disconnected')
            if self.retry and not self.manually_stoped:
                self.update_and_retry(_('Not connected'), self.retry_interval)
                self.set_action_button('disconnect')
            else:
                self.set_action_button('connect')
        else:
            self.set_state('failed')
        
        self.has_connected = False
        
    def cancel(self, widget=None, event=None):
        '''Gets called when the user presses Cancel button'''
        if self.proc:
            # FIXME: Kill the process.
            self.proc.kill()
        exit()
        
    def host_changed(self, widget):
        txt = widget.get_text().strip()
        self.action_button.set_property('sensitive', len(txt) > 0)
    
    def set_state(self, state):
        self.stop_spinner()
        
        if state == 'connecting':
            self.start_spinner()
            self.status_label.set_text(_('Connecting to %s...') %self.host)
            self.set_action_button('disconnect')
        elif state == 'connected':
            self.has_connected = True
            mode = 'VNC'
            if self.method_combo.get_active() == 1:
                mode = 'console'
            self.status_icon.set_from_stock(gtk.STOCK_YES, gtk.ICON_SIZE_BUTTON)
            self.status_label.set_text(_('Connection to %s estabilished (mode: %s)') %(self.host, mode))
            self.set_action_button('disconnect')
        elif state == 'disconnected':
            msg = _('Not connected')
            self.status_icon.set_from_stock(gtk.STOCK_NO, gtk.ICON_SIZE_BUTTON)
            self.status_label.set_text(msg)
        
        elif state == 'failed':
            msg = _('Failed to connect to %s') %self.host
            self.status_label.set_text(msg)
            self.status_icon.set_from_stock(gtk.STOCK_DIALOG_ERROR, gtk.ICON_SIZE_BUTTON)
            
            if self.retry:
                self.update_and_retry(msg, self.retry_interval)
                self.set_action_button('disconnect')
            else:
                self.set_action_button('connect')
    
    def update_and_retry(self, msg, interval):
        if interval == 0:
            self.connect()
        else:
            self.status_label.set_text(msg+' '+_('Retrying in %d...') %interval)
            self.timeout_id = gobject.timeout_add(1000, self.update_and_retry, msg, interval-1)
        return False
    
    def set_action_button(self, mode):
        '''Change the Connect button to Disconnect and vice versa,
        according to mode and setting the correct signals.'''
        
        callback = None
        btn = self.action_button
        if mode == 'connect':
            btn.set_label(gtk.STOCK_CONNECT)
            callback = self.connect
        elif mode == 'disconnect':
            btn.set_label(gtk.STOCK_DISCONNECT)
            callback = self.disconnect
        
        if callback:
            btn.disconnect(self.action_signal_handler)
            self.action_signal_handler = btn.connect('clicked', callback)
    
    def start_spinner(self):
        '''Replace the status icon with a running spinner'''
        self.status_icon.hide()
        self.spinner.show()
        self.spinner.start()
    
    def stop_spinner(self):
        '''Replace the spinner with the status icon'''
        self.spinner.stop()
        self.spinner.hide()
        self.status_icon.show()
        
    def toggle_retry(self, widg):
        self.retry = not self.retry

        
if __name__ == '__main__':
    Support()
    gtk.main()
